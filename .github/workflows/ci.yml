name: CI/CD Pipeline

on:
  push:
    branches: [ '**' ]  # Run on all branches
  pull_request:
    branches: [ main, master ]  # Accept PRs to main/master

jobs:
  # Validate commit messages on pull requests
  commit-lint:
    name: Validate Commit Messages
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: Install commitlint
      run: |
        npm install -g @commitlint/cli @commitlint/config-conventional
        
    - name: Validate commit messages
      run: |
        # Get the base branch commit
        git fetch origin ${{ github.base_ref }}
        BASE_SHA=$(git merge-base origin/${{ github.base_ref }} HEAD)
        
        # Validate each commit message in the PR
        for commit in $(git rev-list $BASE_SHA..HEAD); do
          echo "Validating commit: $commit"
          git log --format="%B" -n 1 $commit | npx commitlint
        done

  test:
    name: Test
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.24'
        
    # Enhanced Go module caching with better key strategy
    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: |
          ~/go/pkg/mod
          ~/.cache/go-build
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}-${{ hashFiles('**/*.go') }}
        restore-keys: |
          ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}-
          ${{ runner.os }}-go-
          
    # Cache Go build cache for faster compilation
    - name: Cache Go build cache
      uses: actions/cache@v4
      with:
        path: ~/.cache/go-build
        key: ${{ runner.os }}-gobuild-${{ hashFiles('**/*.go') }}
        restore-keys: |
          ${{ runner.os }}-gobuild-
          
    - name: Download dependencies
      run: go mod download
      timeout-minutes: 3
      
    - name: Verify dependencies
      run: go mod verify
      timeout-minutes: 1
      
    # Build with timing and caching optimization
    - name: Build applications (cached)
      run: |
        echo "ðŸš€ Building applications with caching..."
        start_time=$(date +%s)
        
        echo "Building main application..."
        go build -o pihole-analyzer ./cmd/pihole-analyzer
        
        echo "Building test runner..."
        go build -o pihole-analyzer-test ./cmd/pihole-analyzer-test
        
        end_time=$(date +%s)
        build_duration=$((end_time - start_time))
        echo "âœ… Build completed in ${build_duration}s"
      timeout-minutes: 3
      
    # Cache built binaries for use in other jobs
    - name: Cache built binaries
      uses: actions/cache@v4
      with:
        path: |
          pihole-analyzer
          pihole-analyzer-test
        key: ${{ runner.os }}-binaries-${{ github.sha }}
        
    - name: Run unit tests
      run: |
        echo "Running Go unit tests..."
        go test -v -timeout=5m -run="^Test[^C]" ./...
      timeout-minutes: 6
      
    - name: Validate integration test script
      run: |
        echo "Validating integration test script..."
        chmod +x ./scripts/integration-test.sh
        ./scripts/integration-test.sh --help || echo "Integration test script ready"
      timeout-minutes: 1
      
    - name: Run integration tests
      run: |
        echo "Building Pi-hole Network Analyzer..."
        go build -o pihole-analyzer ./cmd/pihole-analyzer
        echo "Building test runner..."
        go build -o pihole-analyzer-test ./cmd/pihole-analyzer-test
        echo "Running comprehensive integration test suite..."
        ./pihole-analyzer-test --test
      timeout-minutes: 8
      
    - name: Run performance benchmarks
      run: |
        echo "Running performance benchmarks..."
        go test -bench=. -run=Benchmark -timeout=3m ./...
      timeout-minutes: 4
        
    - name: Check code formatting
      run: |
        if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
          echo "Code formatting issues found:"
          gofmt -s -l .
          exit 1
        fi
      timeout-minutes: 1
        
    - name: Run go vet
      run: go vet ./...
      timeout-minutes: 2

  validate-integration-tests:
    name: Validate Integration Test Framework
    runs-on: ubuntu-latest
    timeout-minutes: 8
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.24'
        
    - name: Test integration script functionality
      run: |
        echo "ðŸ§ª Testing integration test script framework..."
        chmod +x ./scripts/integration-test.sh
        
        # Test script help and validation
        echo "Testing script validation..."
        if ./scripts/integration-test.sh 2>&1 | grep -q "Validating test environment"; then
          echo "âœ… Script validation working"
        else
          echo "âŒ Script validation failed"
          exit 1
        fi
      timeout-minutes: 3
      
    - name: Verify test scenarios are supported
      run: |
        echo "ðŸ” Verifying all test scenarios are supported..."
        scenarios=("pihole-db" "colorized-output" "all-features")
        
        for scenario in "${scenarios[@]}"; do
          echo "Checking scenario: $scenario"
          # Test that scenario is recognized (will fail gracefully without binary)
          if ./scripts/integration-test.sh "$scenario" 2>&1 | grep -q "Binary.*not found\|Validating test environment"; then
            echo "âœ… Scenario '$scenario' is supported"
          else
            echo "âŒ Scenario '$scenario' is not supported"
            exit 1
          fi
        done
      timeout-minutes: 4

  integration-test:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [test, validate-integration-tests]
    timeout-minutes: 15
    
    strategy:
      matrix:
        go-version: ['1.24']
        test-scenario: ['pihole-db', 'colorized-output', 'all-features']
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Go ${{ matrix.go-version }}
      uses: actions/setup-go@v5
      with:
        go-version: ${{ matrix.go-version }}
        
    # Enhanced caching strategy for matrix builds
    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: |
          ~/go/pkg/mod
          ~/.cache/go-build
        key: ${{ runner.os }}-go-${{ matrix.go-version }}-${{ hashFiles('**/go.sum') }}-${{ hashFiles('**/*.go') }}
        restore-keys: |
          ${{ runner.os }}-go-${{ matrix.go-version }}-${{ hashFiles('**/go.sum') }}-
          ${{ runner.os }}-go-${{ matrix.go-version }}-
          ${{ runner.os }}-go-
          
    # Try to restore cached binaries first
    - name: Restore cached binaries
      id: cache-binaries
      uses: actions/cache@v4
      with:
        path: |
          pihole-analyzer
          pihole-analyzer-test
        key: ${{ runner.os }}-binaries-${{ github.sha }}
        
    - name: Download dependencies (if cache miss)
      if: steps.cache-binaries.outputs.cache-hit != 'true'
      run: go mod download
      timeout-minutes: 3
      
    - name: Build application (if cache miss)
      if: steps.cache-binaries.outputs.cache-hit != 'true'
      run: |
        echo "ðŸ—ï¸ Cache miss - building for integration tests with Go ${{ matrix.go-version }}..."
        start_time=$(date +%s)
        
        go build -race -o pihole-analyzer ./cmd/pihole-analyzer
        go build -o pihole-analyzer-test ./cmd/pihole-analyzer-test
        chmod +x pihole-analyzer pihole-analyzer-test
        
        end_time=$(date +%s)
        build_duration=$((end_time - start_time))
        echo "âœ… Fresh build completed in ${build_duration}s"
      timeout-minutes: 3
      
    - name: Use cached binaries
      if: steps.cache-binaries.outputs.cache-hit == 'true'
      run: |
        echo "ðŸš€ Using cached binaries - skipping build!"
        chmod +x pihole-analyzer pihole-analyzer-test
        ls -la pihole-analyzer*
      
    - name: Run scenario-specific integration tests
      run: |
        echo "ðŸ§ª Running integration tests for scenario: ${{ matrix.test-scenario }}"
        chmod +x ./scripts/integration-test.sh
        # Set CI environment variable for integration tests
        CI=true ./scripts/integration-test.sh "${{ matrix.test-scenario }}"
      timeout-minutes: 10
      
    - name: Test cross-platform compatibility (with caching)
      run: |
        echo "ðŸŒ Testing cross-platform builds with caching..."
        start_time=$(date +%s)
        
        # Use Go build cache for faster cross-platform builds
        echo "Building Windows AMD64..."
        GOOS=windows GOARCH=amd64 go build -o test-windows.exe ./cmd/pihole-analyzer
        
        echo "Building macOS AMD64..."
        GOOS=darwin GOARCH=amd64 go build -o test-darwin ./cmd/pihole-analyzer
        
        echo "Building Linux ARM64..."
        GOOS=linux GOARCH=arm64 go build -o test-linux-arm64 ./cmd/pihole-analyzer
        
        end_time=$(date +%s)
        build_duration=$((end_time - start_time))
        echo "âœ… Cross-platform builds completed in ${build_duration}s"
        
        # Clean up test binaries
        rm -f test-windows.exe test-darwin test-linux-arm64
      timeout-minutes: 4
      
    # Cache cross-platform build cache for production builds
    - name: Cache cross-platform build artifacts
      uses: actions/cache@v4
      with:
        path: ~/.cache/go-build
        key: ${{ runner.os }}-crossbuild-${{ hashFiles('**/*.go') }}-${{ matrix.test-scenario }}
        restore-keys: |
          ${{ runner.os }}-crossbuild-${{ hashFiles('**/*.go') }}-
          ${{ runner.os }}-crossbuild-
      
    - name: Integration test report
      run: |
        echo "ðŸ“Š Integration Test Report - ${{ matrix.test-scenario }} on Go ${{ matrix.go-version }}"
        echo "âœ… Scenario: ${{ matrix.test-scenario }}"
        echo "âœ… Go Version: ${{ matrix.go-version }}"
        echo "âœ… Platform: Ubuntu Latest"
        echo "âœ… All integration tests passed!"
      if: success()
      
    - name: Upload integration test artifacts
      uses: actions/upload-artifact@v4
      if: failure()
      with:
        name: integration-test-failure-${{ matrix.go-version }}-${{ matrix.test-scenario }}
        path: |
          testing/fixtures/
          *.log
          core
        retention-days: 7

  security:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: [test, integration-test]
    timeout-minutes: 10
    continue-on-error: true
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.24'
        
    - name: Run govulncheck
      run: |
        echo "Installing govulncheck..."
        go install golang.org/x/vuln/cmd/govulncheck@latest
        echo "Running vulnerability check..."
        govulncheck ./... || echo "âš ï¸ Vulnerabilities found but continuing build"
      timeout-minutes: 5

  build-check:
    name: Build Check (Feature Branches)
    runs-on: ubuntu-latest
    needs: [test, integration-test]
    timeout-minutes: 10
    # Only run build check on non-main/master branches
    if: github.ref != 'refs/heads/main' && github.ref != 'refs/heads/master'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.24'
        
    # Enhanced caching for feature branch builds
    - name: Cache Go modules and build cache
      uses: actions/cache@v4
      with:
        path: |
          ~/go/pkg/mod
          ~/.cache/go-build
        key: ${{ runner.os }}-go-feature-${{ hashFiles('**/go.sum') }}-${{ hashFiles('**/*.go') }}
        restore-keys: |
          ${{ runner.os }}-go-feature-${{ hashFiles('**/go.sum') }}-
          ${{ runner.os }}-go-feature-
          ${{ runner.os }}-go-
          
    # Try to restore cached binaries from test job
    - name: Restore cached binaries
      id: cache-binaries
      uses: actions/cache@v4
      with:
        path: |
          pihole-analyzer
          pihole-analyzer-test
        key: ${{ runner.os }}-binaries-${{ github.sha }}
        
    - name: Download dependencies (if needed)
      if: steps.cache-binaries.outputs.cache-hit != 'true'
      run: go mod download
      timeout-minutes: 3
      
    - name: Build verification (cached or fresh)
      run: |
        if [[ "${{ steps.cache-binaries.outputs.cache-hit }}" == "true" ]]; then
          echo "ðŸš€ Using cached binaries for build verification!"
          ls -la pihole-analyzer*
          echo "âœ… Build verification successful - using cached artifacts!"
        else
          echo "ðŸ” Cache miss - performing fresh build verification for feature branch..."
          start_time=$(date +%s)
          
          echo "Building for Linux AMD64..."
          GOOS=linux GOARCH=amd64 go build -o /tmp/test-build ./cmd/pihole-analyzer
          
          end_time=$(date +%s)
          build_duration=$((end_time - start_time))
          echo "âœ… Build verification successful in ${build_duration}s - ready for merge!"
          rm -f /tmp/test-build
        fi
      timeout-minutes: 5

  build:
    name: Build and Release
    runs-on: ubuntu-latest
    needs: [test, integration-test, security]
    timeout-minutes: 15
    # Only run builds on main/master branch
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
        
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.24'
        
    # Enhanced caching for production builds
    - name: Cache Go modules and build cache
      uses: actions/cache@v4
      with:
        path: |
          ~/go/pkg/mod
          ~/.cache/go-build
        key: ${{ runner.os }}-go-prod-${{ hashFiles('**/go.sum') }}-${{ hashFiles('**/*.go') }}
        restore-keys: |
          ${{ runner.os }}-go-prod-${{ hashFiles('**/go.sum') }}-
          ${{ runner.os }}-go-prod-
          ${{ runner.os }}-go-
          
    # Restore cross-platform build cache from integration tests
    - name: Restore cross-platform build cache
      uses: actions/cache@v4
      with:
        path: ~/.cache/go-build
        key: ${{ runner.os }}-crossbuild-${{ hashFiles('**/*.go') }}-all-features
        restore-keys: |
          ${{ runner.os }}-crossbuild-${{ hashFiles('**/*.go') }}-
          ${{ runner.os }}-crossbuild-
          
    - name: Download dependencies
      run: go mod download
      timeout-minutes: 3
      
    - name: Generate version info
      id: version
      run: |
        # Generate version based on commit hash and date
        VERSION="v$(date +%Y.%m.%d)-$(git rev-parse --short HEAD)"
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "ðŸ·ï¸ Version: $VERSION"
      
    - name: Build multi-platform binaries (optimized)
      run: |
        echo "ðŸš€ Building production binaries for version ${{ steps.version.outputs.version }} with caching..."
        VERSION="${{ steps.version.outputs.version }}"
        start_time=$(date +%s)
        
        # Build in parallel where possible using background jobs
        echo "Starting parallel builds..."
        
        # Linux builds
        echo "Building Linux AMD64..."
        GOOS=linux GOARCH=amd64 go build -ldflags "-X main.Version=$VERSION" -o pihole-analyzer-linux-amd64 ./cmd/pihole-analyzer &
        LINUX_AMD64_PID=$!
        
        echo "Building Linux ARM64..."
        GOOS=linux GOARCH=arm64 go build -ldflags "-X main.Version=$VERSION" -o pihole-analyzer-linux-arm64 ./cmd/pihole-analyzer &
        LINUX_ARM64_PID=$!
        
        # Windows builds
        echo "Building Windows AMD64..."
        GOOS=windows GOARCH=amd64 go build -ldflags "-X main.Version=$VERSION" -o pihole-analyzer-windows-amd64.exe ./cmd/pihole-analyzer &
        WIN_AMD64_PID=$!
        
        echo "Building Windows ARM64..."
        GOOS=windows GOARCH=arm64 go build -ldflags "-X main.Version=$VERSION" -o pihole-analyzer-windows-arm64.exe ./cmd/pihole-analyzer &
        WIN_ARM64_PID=$!
        
        # macOS builds
        echo "Building macOS AMD64..."
        GOOS=darwin GOARCH=amd64 go build -ldflags "-X main.Version=$VERSION" -o pihole-analyzer-darwin-amd64 ./cmd/pihole-analyzer &
        MAC_AMD64_PID=$!
        
        echo "Building macOS ARM64..."
        GOOS=darwin GOARCH=arm64 go build -ldflags "-X main.Version=$VERSION" -o pihole-analyzer-darwin-arm64 ./cmd/pihole-analyzer &
        MAC_ARM64_PID=$!
        
        # Wait for all builds to complete
        echo "Waiting for parallel builds to complete..."
        wait $LINUX_AMD64_PID && echo "âœ… Linux AMD64 build completed"
        wait $LINUX_ARM64_PID && echo "âœ… Linux ARM64 build completed"
        wait $WIN_AMD64_PID && echo "âœ… Windows AMD64 build completed"
        wait $WIN_ARM64_PID && echo "âœ… Windows ARM64 build completed"
        wait $MAC_AMD64_PID && echo "âœ… macOS AMD64 build completed"
        wait $MAC_ARM64_PID && echo "âœ… macOS ARM64 build completed"
        
        end_time=$(date +%s)
        build_duration=$((end_time - start_time))
        echo "âœ… All platform builds completed in ${build_duration}s (with parallelization and caching)"
        
        # Create checksums
        echo "ðŸ“‹ Generating checksums..."
        sha256sum pihole-analyzer-* > checksums.txt
        
        # List all files with sizes
        echo "ðŸ“¦ Build artifacts:"
        ls -lah pihole-analyzer-* checksums.txt
        
        # Build size report
        echo "ðŸ“Š Build size report:"
        du -h pihole-analyzer-* | sort -hr
      timeout-minutes: 8
        
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: pihole-analyzer-${{ steps.version.outputs.version }}
        path: |
          pihole-analyzer-linux-*
          pihole-analyzer-windows-*.exe
          pihole-analyzer-darwin-*
          checksums.txt
        retention-days: 90
        
    - name: Create Release (if tag)
      uses: actions/create-release@v1
      if: startsWith(github.ref, 'refs/tags/')
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref }}
        release_name: Release ${{ github.ref }}
        draft: false
        prerelease: false
